*** ROUGH DRAFT ***


#python #python3 #micropython #microcontrollers #firmware #firmwareengineer 

git clone git@github.com:micropython/micropython.git

cd micropython

STEP 1: Setting up the toolchain and ESP-IDF on MAC
	* The ESP-IDF changes quickly and MicroPython only supports certain versions. The git hash of these versions (one for 3.x, one for 4.x) can be found by running make without a configured ESPIDF. Then you can fetch the required IDF using the following command:
		cd ports/esp32
		make ESPIDF=  # This will print the supported hashes, copy the one you want.
		export ESPIDF=$HOME/src/github.com/espressif/esp-idf
		mkdir -p $ESPIDF
		git clone https://github.com/espressif/esp-idf.git $ESPIDF
                cd $ESPIDF
		git checkout <Current supported ESP-IDF commit hash>
		git submodule update --init --recursive

STEP 2: Python3 dependencies
	* Install Python3 dependencies
		pip3 install pyserial
		pip3 install pyparsing

	* FIRST TIME SETUP: Setup a Python virtual environment from scratch
		cd /Users/developer/Documents/micropython/ports/esp32
		python3 -m venv build-venv
		source build-venv/bin/activate
		pip install --upgrade pip
		pip install -r $ESPIDF/requirements.txt
	* To re-enter this virtual environment in future sessions, you only need to source the activate script
		cd /Users/developer/Documents/micropython/ports/esp32
		source build-venv/bin/activate

STEP 3: Downloading pre-built toolchain manually (IDF 3.x and 4.x)
	* Install PIP
		sudo easy_install pip
	* Download ESP32 toolchain
		https://dl.espressif.com/dl/xtensa-esp32-elf-osx-1.22.0-80-g6c4433a-5.2.0.tar.gz
	* Toolchain setup
		mkdir -p ~/esp
		cd ~/esp
		tar -xzf ~/Downloads/xtensa-esp32-elf-osx-1.22.0-80-g6c4433a-5.2.0.tar.gz
	* To use it, you will need to update your PATH environment variable in ~/.profile file. 
	* To make xtensa-esp32-elf available for all terminal sessions, add the following line to your ~/.profile file.
		export PATH=$HOME/esp/xtensa-esp32-elf/bin:$PATH
	* You will need to update your PATH environment variable to include the ESP32 toolchain.
		export PATH=$PATH:$HOME/esp/crosstool-NG/builds/xtensa-esp32-elf/bin

STEP 4: Configuring the MicroPython build
	* Go to ports/esp32
		cd /Users/developer/Documents/micropython/ports/esp32
	* OPTIONAL: Create a new file in the ports/esp32 directory called makefile (or GNUmakefile) and add the following lines to that file.
		ESPIDF ?= $HOME/src/github.com/espressif/esp-idf
		BOARD ?= GENERIC
		#PORT ?= /dev/cu.SLAB_USBtoUART
		#FLASH_MODE ?= qio
		#FLASH_SIZE ?= 4MB
		#CROSS_COMPILE ?= xtensa-esp32-elf-

		include Makefile
	* NOTE ABOVE STEP: I only had to update this file and change the PORT to /dev/cu.SLAB_USBtoUART
		vim makefile
		...
		PORT ?= /dev/cu.SLAB_USBtoUART
		...

STEP 5: Build firmware
	* Set the make variable to the esp32
		make BOARD=ESP32
	* The MicroPython cross-compiler must be built to pre-compile some of the built-in scripts to bytecode
		cd /Users/developer/Documents/micropython/mpy-cross
		make mpy-cross
	* Make ESP specific submodules and firmware
		cd /Users/developer/Documents/micropython/ports/esp32
		make submodules
		make
	* OPTIONAL - If you are installing MicroPython to your module for the first time, or after 
	* installing any other firmware, you should first erase the flash completely
		make erase
	* To flash the MicroPython firmware to your ESP32 use the below.
		make deploy

STEP 6: Install pyboard.py
	* Copy pyboard.py from latest - https://github.com/micropython/micropython/blob/master/tools/pyboard.py
		chmod +x pyboard.py
		
STEP 7: Run pyboard.py
	* cd /Users/developer/Documents/MPFD
	* Connect device
		./pyboard.py --device /dev/cu.SLAB_USBtoUART main.py
		
		OR
		
		./pyboard.py --device /dev/cu.SLAB_USBtoUART
		PRESS EN BUTTON ON BOARD TO LAUNCH REPL
		
		
		



***********
inisetup.py
***********

		
import uos
from flashbdev import bdev


def check_bootsec():
    buf = bytearray(bdev.ioctl(5, 0))  # 5 is SEC_SIZE
    bdev.readblocks(0, buf)
    empty = True
    for b in buf:
        if b != 0xFF:
            empty = False
            break
    if empty:
        return True
    fs_corrupted()


def fs_corrupted():
    import time

    while 1:
        print(
            """\
FAT filesystem appears to be corrupted. If you had important data there, you
may want to make a flash snapshot to try to recover it. Otherwise, perform
factory reprogramming of MicroPython firmware (completely erase flash, followed
by firmware programming).
"""
        )
        time.sleep(3)


def setup():
    check_bootsec()
    print("Performing initial setup")
    uos.VfsLfs2.mkfs(bdev)
    vfs = uos.VfsLfs2(bdev)
    uos.mount(vfs, "/")
# START - USED IN PROD
# --------------------
#     with open("boot.py", "w") as f:
#         f.write(
#             """\
# # This file is executed on every boot (including wake-boot from deepsleep)
# #import esp
# #esp.osdebug(None)
# #import webrepl
# #webrepl.start()
# """
#        )
# ------------------
# END - USED IN PROD
    return vfs











********
_boot.py
********


import gc
import uos
from flashbdev import bdev

try:
    if bdev:
        uos.mount(bdev, "/")
except OSError:
    import inisetup

    vfs = inisetup.setup()

gc.collect()

# START - USED IN PROD
# --------------------
import bluetooth
# Start BLE stack
ble = bluetooth.BLE()
ble.active(True)
# Debug off (added because NimBLE's log level init function is reset)
import esp; esp.osdebug(None)
import main
# ------------------
# END - USED IN PROD













******
main.c
******

/*
 * This file is part of the MicroPython project, http://micropython.org/
 *
 * Development of the code in this file was sponsored by Microbric Pty Ltd
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "nvs_flash.h"
#include "esp_task.h"
#include "soc/cpu.h"
#include "esp_log.h"
#if MICROPY_ESP_IDF_4
#include "esp32/spiram.h"
#else
#include "esp_spiram.h"
#endif

#include "py/stackctrl.h"
#include "py/nlr.h"
#include "py/compile.h"
#include "py/runtime.h"
#include "py/persistentcode.h"
#include "py/repl.h"
#include "py/gc.h"
#include "py/mphal.h"
#include "lib/mp-readline/readline.h"
#include "lib/utils/pyexec.h"
#include "uart.h"
#include "modmachine.h"
#include "modnetwork.h"
#include "mpthreadport.h"

#if MICROPY_BLUETOOTH_NIMBLE
#include "extmod/modbluetooth.h"
#endif

// MicroPython runs as a task under FreeRTOS
#define MP_TASK_PRIORITY        (ESP_TASK_PRIO_MIN + 1)
#define MP_TASK_STACK_SIZE      (16 * 1024)

int vprintf_null(const char *format, va_list ap) {
    // do nothing: this is used as a log target during raw repl mode
    return 0;
}

void mp_task(void *pvParameter) {
    volatile uint32_t sp = (uint32_t)get_sp();
    #if MICROPY_PY_THREAD
    mp_thread_init(pxTaskGetStackStart(NULL), MP_TASK_STACK_SIZE / sizeof(uintptr_t));
    #endif
    uart_init();

    // TODO: CONFIG_SPIRAM_SUPPORT is for 3.3 compatibility, remove after move to 4.0.
    #if CONFIG_ESP32_SPIRAM_SUPPORT || CONFIG_SPIRAM_SUPPORT
    // Try to use the entire external SPIRAM directly for the heap
    size_t mp_task_heap_size;
    void *mp_task_heap = (void *)0x3f800000;
    switch (esp_spiram_get_chip_size()) {
        case ESP_SPIRAM_SIZE_16MBITS:
            mp_task_heap_size = 2 * 1024 * 1024;
            break;
        case ESP_SPIRAM_SIZE_32MBITS:
        case ESP_SPIRAM_SIZE_64MBITS:
            mp_task_heap_size = 4 * 1024 * 1024;
            break;
        default:
            // No SPIRAM, fallback to normal allocation
            mp_task_heap_size = heap_caps_get_largest_free_block(MALLOC_CAP_8BIT);
            mp_task_heap = malloc(mp_task_heap_size);
            break;
    }
    #else
    // Allocate the uPy heap using malloc and get the largest available region
    size_t mp_task_heap_size = heap_caps_get_largest_free_block(MALLOC_CAP_8BIT);
    void *mp_task_heap = malloc(mp_task_heap_size);
    #endif

soft_reset:
    // initialise the stack pointer for the main thread
    mp_stack_set_top((void *)sp);
    mp_stack_set_limit(MP_TASK_STACK_SIZE - 1024);
    gc_init(mp_task_heap, mp_task_heap + mp_task_heap_size);
    mp_init();
    mp_obj_list_init(mp_sys_path, 0);
    mp_obj_list_append(mp_sys_path, MP_OBJ_NEW_QSTR(MP_QSTR_));
    mp_obj_list_append(mp_sys_path, MP_OBJ_NEW_QSTR(MP_QSTR__slash_lib));
    mp_obj_list_init(mp_sys_argv, 0);
    readline_init0();

    // initialise peripherals
    machine_pins_init();

    // run boot-up scripts
    pyexec_frozen_module("_boot.py");
    // pyexec_file_if_exists("boot.py");
    // if (pyexec_mode_kind == PYEXEC_MODE_FRIENDLY_REPL) {
    //     pyexec_file_if_exists("main.py");
    // }

    // for (;;) {
    //     if (pyexec_mode_kind == PYEXEC_MODE_RAW_REPL) {
    //         vprintf_like_t vprintf_log = esp_log_set_vprintf(vprintf_null);
    //         if (pyexec_raw_repl() != 0) {
    //             break;
    //         }
    //         esp_log_set_vprintf(vprintf_log);
    //     } else {
    //         if (pyexec_friendly_repl() != 0) {
    //             break;
    //         }
    //     }
    // }

    #if MICROPY_BLUETOOTH_NIMBLE
    mp_bluetooth_deinit();
    #endif

    machine_timer_deinit_all();

    #if MICROPY_PY_THREAD
    mp_thread_deinit();
    #endif

    gc_sweep_all();

    mp_hal_stdout_tx_str("MPY: soft reboot\r\n");

    // deinitialise peripherals
    machine_pins_deinit();
    usocket_events_deinit();

    mp_deinit();
    fflush(stdout);
    goto soft_reset;
}

void app_main(void) {
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        nvs_flash_erase();
        nvs_flash_init();
    }
    xTaskCreatePinnedToCore(mp_task, "mp_task", MP_TASK_STACK_SIZE / sizeof(StackType_t), NULL, MP_TASK_PRIORITY, &mp_main_task_handle, MP_TASK_COREID);
}

void nlr_jump_fail(void *val) {
    printf("NLR jump failed, val=%p\n", val);
    esp_restart();
}

// modussl_mbedtls uses this function but it's not enabled in ESP IDF
void mbedtls_debug_set_threshold(int threshold) {
    (void)threshold;
}

void *esp_native_code_commit(void *buf, size_t len, void *reloc) {
    len = (len + 3) & ~3;
    uint32_t *p = heap_caps_malloc(len, MALLOC_CAP_EXEC);
    if (p == NULL) {
        m_malloc_fail(len);
    }
    if (reloc) {
        mp_native_relocate(reloc, buf, (uintptr_t)p);
    }
    memcpy(p, buf, len);
    return p;
}


